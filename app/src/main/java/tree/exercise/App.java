/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tree.exercise;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.awt.geom.Point2D;

public class App {
  private static String[] species = {"Pine", "Cedar", "Juniper", "Fir", "Cypress", "Redwood", "Sequoia", "Yew", "Hemlock", "Oak"}; 
  private static ArrayList<Tree> forest = new ArrayList<Tree>();
  public static void main(String[] args) {
    int x = 1;
    for(int i = 0; i < 2; i ++) {
      for(String specie: species) {
        Integer xLocation = treePlacement();
        Integer yLocation = treePlacement();
        // if (isPlotEmpy(xLocation, yLocation)){
        //   forest.add(new Tree(specie, xLocation, yLocation));
        // } 

        while (isPlotEmpy(xLocation, yLocation) == false){
          xLocation = treePlacement();
          yLocation = treePlacement();
          // forest.add(new Tree(specie, xLocation, yLocation));
        }
        forest.add(new Tree(specie, xLocation, yLocation));
        
        growAllTrees();
        x++;
      }
    }
    int size = forest.size(); 
    System.out.println("size of forestlist after creating: " + size);
    String[][] grid = fillGrid(10, 10, "x");
    String[][] filledForest = findLocationOfTreeInForest(grid);
    createForestMap(filledForest);

  }

  private static Integer treePlacement(){
    Random rand = new Random();
    int randomNum = rand.nextInt((10 - 1) + 1) + 1;
    return randomNum;
  }

  private static Boolean isPlotEmpy(int x, int y){
    for(Tree tree: forest) {
      if (tree.positionInForest[0] == x && tree.positionInForest[1] == y){
        return false;
      }
    }
    return true;
  }

  static String[][] fillGrid(int rows, int cols, String cell){
    String[][] grid = new String[rows][cols];

    String[] row = new String[cols];
    Arrays.fill(row, cell);
    grid[0] = row;
    for (int i = 1; i < rows; i++) {
        grid[i] = Arrays.copyOf(row, cols);
    }
    grid[5][5] = "P";
    return grid;
  }

  static String[][] findLocationOfTreeInForest(String[][] grid){
    for(Tree tree: forest) {
      grid[tree.positionInForest[0]-1][tree.positionInForest[1]-1] = "P";
    }
    return grid;
  }

  static void createForestMap(String[][] grid) {
    
    for (int i = 0; i < grid.length; i++) {
        if (i == 0) {
            System.out.print("   ");
            for (int j = 0; j < grid[0].length; j++) {
                System.out.printf("%2d ", j + 1);
            }
            System.out.println();
        }
        for (int j = 0; j < grid[i].length; j++) {
            if (j == 0) {
                System.out.printf("%2d:", i + 1);
            }
            System.out.printf("%2s ", grid[i][j]);
        }
        System.out.println();
    }
}

  private static Double calculateDistanceBetweenTwoPoints(int x, int y, int x_nearest, int y_nearest){
    return Point2D.distance(x,y,x_nearest,y_nearest);
  }

  private static Double findNearestTreeDistance(Tree tree){
    Double nearestTree = Double.MAX_VALUE;

    for(Tree otherTree: forest) {
      if (tree != otherTree){
        Integer x = tree.positionInForest[0];
        Integer y = tree.positionInForest[1];
        Integer xNearest = otherTree.positionInForest[0];
        Integer yNearest = otherTree.positionInForest[0];
        if (nearestTree > calculateDistanceBetweenTwoPoints(x, y, xNearest, yNearest)){
          nearestTree = calculateDistanceBetweenTwoPoints(x, y, xNearest, yNearest);
        }
      }
    }
    return nearestTree;
  }

  private static Boolean canPhotosynthesise(Tree tree){
    Double nearestTree = findNearestTreeDistance(tree);
    // System.out.printf("This is the location of the nearest tree %s \n", nearestTree);
    return (nearestTree * 4) > tree.height;
  }

  private static void growAllTrees() {
    for(Tree tree: forest) {
      if (canPhotosynthesise(tree)){
        tree.photosynthesise();
        tree.grow();
      }
    }
  }

}
